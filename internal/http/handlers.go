package apihttp

import (
	"encoding/json"
	"errors"
	"net/http"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
	"go.uber.org/zap"

	"notifications/internal/metrics"
	"notifications/internal/repo"
)

// Handler holds dependencies for HTTP handlers.
type Handler struct {
	repo   *repo.Repository
	logger *zap.Logger
}

// NewHandler creates a new Handler.
func NewHandler(r *repo.Repository, logger *zap.Logger) *Handler {
	return &Handler{
		repo:   r,
		logger: logger,
	}
}

// RegisterSubscription handles POST /v1/subscriptions
func (h *Handler) RegisterSubscription(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	ctx := r.Context()

	var req RegisterSubscriptionRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Warn("failed to decode register subscription request", zap.Error(err))
		h.respondError(w, http.StatusBadRequest, "invalid JSON body", "INVALID_JSON", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/subscriptions", 400)
		return
	}

	if err := req.Validate(); err != nil {
		h.logger.Warn("validation failed for register subscription", zap.Error(err))
		h.respondError(w, http.StatusBadRequest, err.Error(), "VALIDATION_ERROR", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/subscriptions", 400)
		return
	}

	// Check if subscription already exists by endpoint
	existing, err := h.repo.GetDeviceSubscriptionByEndpoint(ctx, req.Endpoint)
	if err == nil {
		// Subscription exists, return it
		h.logger.Info("subscription already exists, returning existing",
			zap.String("subscription_id", existing.ID.String()),
			zap.String("user_id", req.UserID),
		)
		resp := RegisterSubscriptionResponse{
			ID:        existing.ID,
			UserID:    existing.UserID,
			Endpoint:  existing.Endpoint,
			IsActive:  existing.IsActive,
			CreatedAt: existing.CreatedAt,
		}
		h.respondJSON(w, http.StatusOK, resp)
		metrics.IncHTTPRequestsTotal("POST", "/v1/subscriptions", 200)
		metrics.ObserveRequestDuration("POST", "/v1/subscriptions", 200, time.Since(start).Seconds())
		return
	}
	if !errors.Is(err, pgx.ErrNoRows) {
		h.logger.Error("failed to check existing subscription", zap.Error(err))
		h.respondError(w, http.StatusInternalServerError, "internal server error", "INTERNAL_ERROR", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/subscriptions", 500)
		return
	}

	// Create new subscription (ID is auto-generated by database)
	sub, err := h.repo.CreateDeviceSubscription(ctx, repo.CreateDeviceSubscriptionParams{
		UserID:    req.UserID,
		Endpoint:  req.Endpoint,
		P256dh:    req.Keys.P256dh,
		Auth:      req.Keys.Auth,
		DeviceID:  req.DeviceID,
		UserAgent: req.UserAgent,
		Locale:    req.Locale,
		Timezone:  req.Timezone,
	})
	if err != nil {
		h.logger.Error("failed to create subscription", zap.Error(err), zap.String("user_id", req.UserID))
		h.respondError(w, http.StatusInternalServerError, "failed to create subscription", "CREATE_FAILED", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/subscriptions", 500)
		return
	}

	h.logger.Info("subscription created",
		zap.String("subscription_id", sub.ID.String()),
		zap.String("user_id", sub.UserID),
	)

	resp := RegisterSubscriptionResponse{
		ID:        sub.ID,
		UserID:    sub.UserID,
		Endpoint:  sub.Endpoint,
		IsActive:  sub.IsActive,
		CreatedAt: sub.CreatedAt,
	}

	h.respondJSON(w, http.StatusCreated, resp)
	metrics.IncHTTPRequestsTotal("POST", "/v1/subscriptions", 201)
	metrics.ObserveRequestDuration("POST", "/v1/subscriptions", 201, time.Since(start).Seconds())
	metrics.IncPushSubscriptionsTotal(req.UserID)
}

// UnregisterSubscription handles DELETE /v1/subscriptions/:id
func (h *Handler) UnregisterSubscription(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	ctx := r.Context()

	idStr := chi.URLParam(r, "id")
	subID, err := uuid.Parse(idStr)
	if err != nil {
		h.respondError(w, http.StatusBadRequest, "invalid subscription ID", "INVALID_ID", nil)
		metrics.IncHTTPRequestsTotal("DELETE", "/v1/subscriptions/:id", 400)
		return
	}

	// Check if subscription exists
	_, err = h.repo.GetDeviceSubscription(ctx, subID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			h.respondError(w, http.StatusNotFound, "subscription not found", "NOT_FOUND", nil)
			metrics.IncHTTPRequestsTotal("DELETE", "/v1/subscriptions/:id", 404)
			return
		}
		h.logger.Error("failed to get subscription", zap.Error(err), zap.String("subscription_id", idStr))
		h.respondError(w, http.StatusInternalServerError, "internal server error", "INTERNAL_ERROR", nil)
		metrics.IncHTTPRequestsTotal("DELETE", "/v1/subscriptions/:id", 500)
		return
	}

	// Soft delete by deactivating
	if err := h.repo.DeactivateDeviceSubscription(ctx, subID); err != nil {
		h.logger.Error("failed to deactivate subscription", zap.Error(err), zap.String("subscription_id", idStr))
		h.respondError(w, http.StatusInternalServerError, "failed to deactivate subscription", "DELETE_FAILED", nil)
		metrics.IncHTTPRequestsTotal("DELETE", "/v1/subscriptions/:id", 500)
		return
	}

	h.logger.Info("subscription deactivated", zap.String("subscription_id", idStr))

	w.WriteHeader(http.StatusNoContent)
	metrics.IncHTTPRequestsTotal("DELETE", "/v1/subscriptions/:id", 204)
	metrics.ObserveRequestDuration("DELETE", "/v1/subscriptions/:id", 204, time.Since(start).Seconds())
}

// SendNotification handles POST /v1/notifications
func (h *Handler) SendNotification(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	ctx := r.Context()

	var req SendNotificationRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.logger.Warn("failed to decode send notification request", zap.Error(err))
		h.respondError(w, http.StatusBadRequest, "invalid JSON body", "INVALID_JSON", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/notifications", 400)
		return
	}

	if err := req.Validate(); err != nil {
		h.logger.Warn("validation failed for send notification", zap.Error(err))
		h.respondError(w, http.StatusBadRequest, err.Error(), "VALIDATION_ERROR", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/notifications", 400)
		return
	}

	// Check idempotency
	if req.IdempotencyKey != nil {
		existing, err := h.repo.GetNotificationByIdempotencyKey(ctx, req.IdempotencyKey)
		if err == nil {
			// Already exists, return it
			recipientCount, _ := h.repo.CountRecipientsByNotification(ctx, existing.ID)
			h.logger.Info("notification already exists (idempotency)", zap.String("notification_id", existing.ID.String()))
			resp := SendNotificationResponse{
				ID:             existing.ID,
				Type:           existing.Type,
				Status:         existing.Status,
				RecipientCount: int(recipientCount),
				CreatedAt:      existing.CreatedAt,
			}
			h.respondJSON(w, http.StatusOK, resp)
			metrics.IncHTTPRequestsTotal("POST", "/v1/notifications", 200)
			return
		}
		if !errors.Is(err, pgx.ErrNoRows) {
			h.logger.Error("failed to check idempotency key", zap.Error(err))
			h.respondError(w, http.StatusInternalServerError, "internal server error", "INTERNAL_ERROR", nil)
			metrics.IncHTTPRequestsTotal("POST", "/v1/notifications", 500)
			return
		}
	}

	// Convert data to JSON
	dataJSON, err := req.DataAsJSON()
	if err != nil {
		h.logger.Warn("failed to marshal notification data", zap.Error(err))
		h.respondError(w, http.StatusBadRequest, "invalid data field", "INVALID_DATA", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/notifications", 400)
		return
	}

	// Create notification and recipients in a transaction
	var notif repo.Notification
	var recipientCount int

	err = h.repo.WithTx(ctx, func(q *repo.Queries) error {
		// Create notification (ID is auto-generated by database)
		ttl := int32(0)
		if req.TTLSeconds != nil {
			ttl = int32(*req.TTLSeconds)
		}

		notif, err = q.CreateNotification(ctx, repo.CreateNotificationParams{
			IdempotencyKey: req.IdempotencyKey,
			Type:           req.Type,
			Title:          req.Title,
			Body:           req.Body,
			Icon:           req.Icon,
			Url:            req.URL,
			Locale:         req.Locale,
			Data:           dataJSON,
			DedupeKey:      req.DedupeKey,
			TtlSeconds:     &ttl,
			Priority:       req.Priority,
		})
		if err != nil {
			return err
		}

		// Create recipients
		recipientParams := make([]repo.CreateRecipientsBatchParams, len(req.UserIDs))
		for i, userID := range req.UserIDs {
			recipientParams[i] = repo.CreateRecipientsBatchParams{
				NotificationID: notif.ID,
				UserID:         userID,
			}
		}

		inserted, err := q.CreateRecipientsBatch(ctx, recipientParams)
		if err != nil {
			return err
		}
		recipientCount = int(inserted)

		return nil
	})

	if err != nil {
		h.logger.Error("failed to create notification", zap.Error(err), zap.String("type", req.Type))
		h.respondError(w, http.StatusInternalServerError, "failed to create notification", "CREATE_FAILED", nil)
		metrics.IncHTTPRequestsTotal("POST", "/v1/notifications", 500)
		return
	}

	h.logger.Info("notification created",
		zap.String("notification_id", notif.ID.String()),
		zap.String("type", notif.Type),
		zap.Int("recipients", recipientCount),
	)

	resp := SendNotificationResponse{
		ID:             notif.ID,
		Type:           notif.Type,
		Status:         notif.Status,
		RecipientCount: recipientCount,
		CreatedAt:      notif.CreatedAt,
	}

	h.respondJSON(w, http.StatusCreated, resp)
	metrics.IncHTTPRequestsTotal("POST", "/v1/notifications", 201)
	metrics.ObserveRequestDuration("POST", "/v1/notifications", 201, time.Since(start).Seconds())
	metrics.IncNotificationsSent(notif.Type)
}

// GetNotification handles GET /v1/notifications/:id
func (h *Handler) GetNotification(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	ctx := r.Context()

	idStr := chi.URLParam(r, "id")
	notifID, err := uuid.Parse(idStr)
	if err != nil {
		h.respondError(w, http.StatusBadRequest, "invalid notification ID", "INVALID_ID", nil)
		metrics.IncHTTPRequestsTotal("GET", "/v1/notifications/:id", 400)
		return
	}

	notif, err := h.repo.GetNotification(ctx, notifID)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			h.respondError(w, http.StatusNotFound, "notification not found", "NOT_FOUND", nil)
			metrics.IncHTTPRequestsTotal("GET", "/v1/notifications/:id", 404)
			return
		}
		h.logger.Error("failed to get notification", zap.Error(err), zap.String("notification_id", idStr))
		h.respondError(w, http.StatusInternalServerError, "internal server error", "INTERNAL_ERROR", nil)
		metrics.IncHTTPRequestsTotal("GET", "/v1/notifications/:id", 500)
		return
	}

	recipientCount, err := h.repo.CountRecipientsByNotification(ctx, notifID)
	if err != nil {
		h.logger.Error("failed to count recipients", zap.Error(err))
		recipientCount = 0
	}

	// Parse data JSON
	var data map[string]interface{}
	if len(notif.Data) > 0 {
		_ = json.Unmarshal(notif.Data, &data)
	}

	resp := GetNotificationResponse{
		ID:             notif.ID,
		Type:           notif.Type,
		Title:          notif.Title,
		Body:           notif.Body,
		Icon:           notif.Icon,
		URL:            notif.Url,
		Locale:         notif.Locale,
		Data:           data,
		Status:         notif.Status,
		RecipientCount: int(recipientCount),
		CreatedAt:      notif.CreatedAt,
	}

	h.respondJSON(w, http.StatusOK, resp)
	metrics.IncHTTPRequestsTotal("GET", "/v1/notifications/:id", 200)
	metrics.ObserveRequestDuration("GET", "/v1/notifications/:id", 200, time.Since(start).Seconds())
}

// ListDeliveryAttempts handles GET /v1/notifications/:id/attempts
func (h *Handler) ListDeliveryAttempts(w http.ResponseWriter, r *http.Request) {
	start := time.Now()
	ctx := r.Context()

	idStr := chi.URLParam(r, "id")
	notifID, err := uuid.Parse(idStr)
	if err != nil {
		h.respondError(w, http.StatusBadRequest, "invalid notification ID", "INVALID_ID", nil)
		metrics.IncHTTPRequestsTotal("GET", "/v1/notifications/:id/attempts", 400)
		return
	}

	attempts, err := h.repo.ListDeliveryAttemptsByNotification(ctx, notifID)
	if err != nil {
		h.logger.Error("failed to list delivery attempts", zap.Error(err), zap.String("notification_id", idStr))
		h.respondError(w, http.StatusInternalServerError, "internal server error", "INTERNAL_ERROR", nil)
		metrics.IncHTTPRequestsTotal("GET", "/v1/notifications/:id/attempts", 500)
		return
	}

	respAttempts := make([]DeliveryAttemptResponse, len(attempts))
	for i, attempt := range attempts {
		var subID *uuid.UUID
		if attempt.SubscriptionID.Valid {
			id := attempt.SubscriptionID.Bytes
			parsed, _ := uuid.FromBytes(id[:])
			subID = &parsed
		}

		var httpStatus, latencyMs, retryCount *int
		if attempt.HttpStatus != nil {
			status := int(*attempt.HttpStatus)
			httpStatus = &status
		}
		if attempt.LatencyMs != nil {
			latency := int(*attempt.LatencyMs)
			latencyMs = &latency
		}
		if attempt.RetryCount != nil {
			retry := int(*attempt.RetryCount)
			retryCount = &retry
		}

		respAttempts[i] = DeliveryAttemptResponse{
			ID:             attempt.ID,
			NotificationID: attempt.NotificationID,
			SubscriptionID: subID,
			UserID:         attempt.UserID,
			Status:         attempt.Status,
			HTTPStatus:     httpStatus,
			LatencyMs:      latencyMs,
			Error:          attempt.Error,
			RetryCount:     retryCount,
			CreatedAt:      attempt.CreatedAt,
		}
	}

	resp := ListDeliveryAttemptsResponse{
		NotificationID: notifID,
		Attempts:       respAttempts,
		Total:          len(respAttempts),
	}

	h.respondJSON(w, http.StatusOK, resp)
	metrics.IncHTTPRequestsTotal("GET", "/v1/notifications/:id/attempts", 200)
	metrics.ObserveRequestDuration("GET", "/v1/notifications/:id/attempts", 200, time.Since(start).Seconds())
}

// respondJSON writes a JSON response.
func (h *Handler) respondJSON(w http.ResponseWriter, status int, data interface{}) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(data)
}

// respondError writes an error response.
func (h *Handler) respondError(w http.ResponseWriter, status int, message, code string, details map[string]string) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(status)
	_ = json.NewEncoder(w).Encode(ErrorResponse{
		Error:   message,
		Code:    code,
		Details: details,
	})
}
