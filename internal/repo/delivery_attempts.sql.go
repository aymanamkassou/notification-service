// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: delivery_attempts.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countDeliveryAttemptsByNotification = `-- name: CountDeliveryAttemptsByNotification :one
SELECT COUNT(*) FROM notification_attempts
WHERE notification_id = $1
`

func (q *Queries) CountDeliveryAttemptsByNotification(ctx context.Context, notificationID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countDeliveryAttemptsByNotification, notificationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDeliveryAttemptsByStatus = `-- name: CountDeliveryAttemptsByStatus :one
SELECT COUNT(*) FROM notification_attempts
WHERE status = $1
`

func (q *Queries) CountDeliveryAttemptsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countDeliveryAttemptsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDeliveryAttempt = `-- name: CreateDeliveryAttempt :one
INSERT INTO notification_attempts (
  notification_id,
  subscription_id,
  user_id,
  status,
  http_status,
  latency_ms,
  error,
  retry_count
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at
`

type CreateDeliveryAttemptParams struct {
	NotificationID uuid.UUID   `json:"notification_id"`
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	UserID         string      `json:"user_id"`
	Status         string      `json:"status"`
	HttpStatus     *int32      `json:"http_status"`
	LatencyMs      *int32      `json:"latency_ms"`
	Error          *string     `json:"error"`
	RetryCount     *int32      `json:"retry_count"`
}

func (q *Queries) CreateDeliveryAttempt(ctx context.Context, arg CreateDeliveryAttemptParams) (NotificationAttempt, error) {
	row := q.db.QueryRow(ctx, createDeliveryAttempt,
		arg.NotificationID,
		arg.SubscriptionID,
		arg.UserID,
		arg.Status,
		arg.HttpStatus,
		arg.LatencyMs,
		arg.Error,
		arg.RetryCount,
	)
	var i NotificationAttempt
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.SubscriptionID,
		&i.UserID,
		&i.Status,
		&i.HttpStatus,
		&i.LatencyMs,
		&i.Error,
		&i.RetryCount,
		&i.Pruned,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldAttempts = `-- name: DeleteOldAttempts :exec
DELETE FROM notification_attempts
WHERE created_at < $1
`

func (q *Queries) DeleteOldAttempts(ctx context.Context, createdAt time.Time) error {
	_, err := q.db.Exec(ctx, deleteOldAttempts, createdAt)
	return err
}

const findFailedAttemptsBySubscription = `-- name: FindFailedAttemptsBySubscription :many
SELECT id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at FROM notification_attempts
WHERE subscription_id = $1
  AND status = 'failed'
  AND created_at >= $2
ORDER BY created_at DESC
`

type FindFailedAttemptsBySubscriptionParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	CreatedAt      time.Time   `json:"created_at"`
}

func (q *Queries) FindFailedAttemptsBySubscription(ctx context.Context, arg FindFailedAttemptsBySubscriptionParams) ([]NotificationAttempt, error) {
	rows, err := q.db.Query(ctx, findFailedAttemptsBySubscription, arg.SubscriptionID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationAttempt{}
	for rows.Next() {
		var i NotificationAttempt
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.SubscriptionID,
			&i.UserID,
			&i.Status,
			&i.HttpStatus,
			&i.LatencyMs,
			&i.Error,
			&i.RetryCount,
			&i.Pruned,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeliveryAttempt = `-- name: GetDeliveryAttempt :one
SELECT id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at FROM notification_attempts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetDeliveryAttempt(ctx context.Context, id uuid.UUID) (NotificationAttempt, error) {
	row := q.db.QueryRow(ctx, getDeliveryAttempt, id)
	var i NotificationAttempt
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.SubscriptionID,
		&i.UserID,
		&i.Status,
		&i.HttpStatus,
		&i.LatencyMs,
		&i.Error,
		&i.RetryCount,
		&i.Pruned,
		&i.CreatedAt,
	)
	return i, err
}

const getDeliveryStats = `-- name: GetDeliveryStats :one
SELECT
  COUNT(*) as total_attempts,
  COUNT(*) FILTER (WHERE status = 'success') as success_count,
  COUNT(*) FILTER (WHERE status = 'failed') as failed_count,
  AVG(latency_ms) FILTER (WHERE latency_ms IS NOT NULL) as avg_latency_ms
FROM notification_attempts
WHERE created_at >= $1
`

type GetDeliveryStatsRow struct {
	TotalAttempts int64   `json:"total_attempts"`
	SuccessCount  int64   `json:"success_count"`
	FailedCount   int64   `json:"failed_count"`
	AvgLatencyMs  float64 `json:"avg_latency_ms"`
}

func (q *Queries) GetDeliveryStats(ctx context.Context, createdAt time.Time) (GetDeliveryStatsRow, error) {
	row := q.db.QueryRow(ctx, getDeliveryStats, createdAt)
	var i GetDeliveryStatsRow
	err := row.Scan(
		&i.TotalAttempts,
		&i.SuccessCount,
		&i.FailedCount,
		&i.AvgLatencyMs,
	)
	return i, err
}

const listDeliveryAttemptsByNotification = `-- name: ListDeliveryAttemptsByNotification :many
SELECT id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at FROM notification_attempts
WHERE notification_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListDeliveryAttemptsByNotification(ctx context.Context, notificationID uuid.UUID) ([]NotificationAttempt, error) {
	rows, err := q.db.Query(ctx, listDeliveryAttemptsByNotification, notificationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationAttempt{}
	for rows.Next() {
		var i NotificationAttempt
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.SubscriptionID,
			&i.UserID,
			&i.Status,
			&i.HttpStatus,
			&i.LatencyMs,
			&i.Error,
			&i.RetryCount,
			&i.Pruned,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryAttemptsByStatus = `-- name: ListDeliveryAttemptsByStatus :many
SELECT id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at FROM notification_attempts
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDeliveryAttemptsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListDeliveryAttemptsByStatus(ctx context.Context, arg ListDeliveryAttemptsByStatusParams) ([]NotificationAttempt, error) {
	rows, err := q.db.Query(ctx, listDeliveryAttemptsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationAttempt{}
	for rows.Next() {
		var i NotificationAttempt
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.SubscriptionID,
			&i.UserID,
			&i.Status,
			&i.HttpStatus,
			&i.LatencyMs,
			&i.Error,
			&i.RetryCount,
			&i.Pruned,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryAttemptsBySubscription = `-- name: ListDeliveryAttemptsBySubscription :many
SELECT id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at FROM notification_attempts
WHERE subscription_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDeliveryAttemptsBySubscriptionParams struct {
	SubscriptionID pgtype.UUID `json:"subscription_id"`
	Limit          int32       `json:"limit"`
	Offset         int32       `json:"offset"`
}

func (q *Queries) ListDeliveryAttemptsBySubscription(ctx context.Context, arg ListDeliveryAttemptsBySubscriptionParams) ([]NotificationAttempt, error) {
	rows, err := q.db.Query(ctx, listDeliveryAttemptsBySubscription, arg.SubscriptionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationAttempt{}
	for rows.Next() {
		var i NotificationAttempt
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.SubscriptionID,
			&i.UserID,
			&i.Status,
			&i.HttpStatus,
			&i.LatencyMs,
			&i.Error,
			&i.RetryCount,
			&i.Pruned,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeliveryAttemptsByUser = `-- name: ListDeliveryAttemptsByUser :many
SELECT id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at FROM notification_attempts
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListDeliveryAttemptsByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListDeliveryAttemptsByUser(ctx context.Context, arg ListDeliveryAttemptsByUserParams) ([]NotificationAttempt, error) {
	rows, err := q.db.Query(ctx, listDeliveryAttemptsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []NotificationAttempt{}
	for rows.Next() {
		var i NotificationAttempt
		if err := rows.Scan(
			&i.ID,
			&i.NotificationID,
			&i.SubscriptionID,
			&i.UserID,
			&i.Status,
			&i.HttpStatus,
			&i.LatencyMs,
			&i.Error,
			&i.RetryCount,
			&i.Pruned,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSubscriptionAsPruned = `-- name: MarkSubscriptionAsPruned :exec
UPDATE notification_attempts
SET pruned = true
WHERE subscription_id = $1
`

func (q *Queries) MarkSubscriptionAsPruned(ctx context.Context, subscriptionID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markSubscriptionAsPruned, subscriptionID)
	return err
}

const updateDeliveryAttemptStatus = `-- name: UpdateDeliveryAttemptStatus :one
UPDATE notification_attempts
SET
  status = $1,
  http_status = COALESCE($2, http_status),
  latency_ms = COALESCE($3, latency_ms),
  error = COALESCE($4, error),
  retry_count = COALESCE($5, retry_count)
WHERE id = $6
RETURNING id, notification_id, subscription_id, user_id, status, http_status, latency_ms, error, retry_count, pruned, created_at
`

type UpdateDeliveryAttemptStatusParams struct {
	Status     string    `json:"status"`
	HttpStatus *int32    `json:"http_status"`
	LatencyMs  *int32    `json:"latency_ms"`
	Error      *string   `json:"error"`
	RetryCount *int32    `json:"retry_count"`
	ID         uuid.UUID `json:"id"`
}

func (q *Queries) UpdateDeliveryAttemptStatus(ctx context.Context, arg UpdateDeliveryAttemptStatusParams) (NotificationAttempt, error) {
	row := q.db.QueryRow(ctx, updateDeliveryAttemptStatus,
		arg.Status,
		arg.HttpStatus,
		arg.LatencyMs,
		arg.Error,
		arg.RetryCount,
		arg.ID,
	)
	var i NotificationAttempt
	err := row.Scan(
		&i.ID,
		&i.NotificationID,
		&i.SubscriptionID,
		&i.UserID,
		&i.Status,
		&i.HttpStatus,
		&i.LatencyMs,
		&i.Error,
		&i.RetryCount,
		&i.Pruned,
		&i.CreatedAt,
	)
	return i, err
}
